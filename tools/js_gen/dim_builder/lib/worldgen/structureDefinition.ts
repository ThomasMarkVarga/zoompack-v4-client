import {BasicDataHolder} from "../selfWritingJson";

import {NbtStructure, ReplaceBlockCommand, ReplaceEntityCommand} from "./nbtStructure";
import {StructureSet} from "./structureSet";
import {Structure} from "./structure";
import {TemplatePool} from "./templatePool";
import {loadJsonFromPath, navigateUpUntilTargetFolder, removeNamespace} from "../utils";
import {findJigsawBlocks, readNbtFile} from "../nbt/util";
import {Biome} from "./biome";
import path from "path";

export class StructureDefinition extends BasicDataHolder<StructureDefinition> {
    structureSet: StructureSet;
    structures: Structure[] = [];
    nbts: NbtStructure[] = [];

    constructor(name: string = "", namespace: string = "") {
        super();
        this.internalName = name;
        this.internalNamespace = namespace
    }

    async build() {
        console.info(`Building structure ${this.internalNamespace}:${this.internalName}`)
        this.popNameAndNamepace();
        this.structures?.forEach(structure => {
            if (structure.template_pools?.length === 0) {
                const pool = new TemplatePool().withNamespace(this.internalNamespace).withName(structure.internalName).withStructure(`${structure.internalNamespace}:${structure.internalName}`);
                pool.autogenerated = true;
                structure.template_pools = [pool];
            }
        });
        this.popNameAndNamepace();
        for (const nbt of this.nbts) {
            await nbt.build();
        }
    }

    private popNameAndNamepace() {
        this.structures?.forEach(structure => {
            structure.withNamespace(this.internalNamespace);
            structure?.template_pools?.forEach(pool => {
                if (pool.autogenerated) {
                    pool.withNamespace(this.internalNamespace)
                }
            });
            if (structure.internalName === "") {
                structure.withName(this.internalName);
                structure?.template_pools?.forEach(pool => {
                    if (pool.autogenerated) {
                        pool.withName(this.internalName)
                    }
                });
            }
            this.structureSet.withStructure(structure);
        });
        this.structureSet.withNamespace(this.internalNamespace).withName(this.internalName);
        this.nbts?.forEach(nbt => {
            nbt.withNamespace(this.internalNamespace)
            if (nbt.internalName === "") {
                nbt.withName(this.internalName);
            }
        });
    }

    async fromTemplate(pathToStructureSet: string) {
        console.info(`Started decoding structure from ${pathToStructureSet}`)
        const isJar = pathToStructureSet.startsWith("jar:");
        this.structureSet = new StructureSet().fromTemplate(await loadJsonFromPath(pathToStructureSet));
        this.structureSet.withNamespace(this.internalNamespace).withName(this.internalName);
        const worldgenFolder = path.join(navigateUpUntilTargetFolder("worldgen", pathToStructureSet), "worldgen");
        const dataFolder = path.join(navigateUpUntilTargetFolder("data", worldgenFolder), "data");
        for (const structureEntry of this.structureSet.structures) {
            const structure = new Structure().fromTemplate(await loadJsonFromPath(`${worldgenFolder}/structure/${removeNamespace(structureEntry.structure)}.json`));
            this.structures.push(structure);
            if (structure.type === "minecraft:jigsaw" || !!structure.start_pool) {
                const pool = new TemplatePool().fromTemplate(await loadJsonFromPath(`${worldgenFolder}/template_pool/${removeNamespace(structure.start_pool)}.json`));
                pool.withNamespace(this.internalNamespace).withName(this.internalName + '_' + removeNamespace(structure.start_pool));
                structure.template_pools = [pool];
                await this.traversePool(pool, structure, dataFolder);
                structure.start_pool = this.internalNamespace + ':' + this.internalName + '_' + structure.start_pool.split(':')[1];
            }
            else {
                console.warn(`Structure ${`${worldgenFolder}/structure/${removeNamespace(structureEntry.structure)}.json`} has no start_pool. Might be a dynamic structure. Please check to make sure.`)
            }
            structure.withNamespace(this.internalNamespace).withName(removeNamespace(structureEntry.structure));
            structureEntry.structure = this.internalNamespace + ":" + structureEntry.structure.split(":")[1];
        }
        return this;
    }

    private async traversePool(pool: TemplatePool, structure: Structure, dataFolder: string) {
        const poolElements = pool.elements;
        for (const element of poolElements) {
            if (!!element.element.processors && !!element.element.processors.endsWith && element.element.processors.endsWith('empty')) {
                continue;
            }
            if (element.element.element_type === "minecraft:single_pool_element" || element.element.element_type === "minecraft:legacy_single_pool_element") {
                await this.processElement(element.element, dataFolder, structure);
            } else if (element.element.element_type === "minecraft:list_pool_element") {
                for (const listElement of element.element.elements) {
                    await this.processElement(listElement, dataFolder, structure);
                }
            }
        }
    }

    private async processElement(element, dataFolder: string, structure: Structure) {
        console.log(`Started processing element: ${element.location}`);
        let isJar = false;
        let modId = "";
        if (dataFolder.startsWith("jar:")) {
            isJar = true;
            const split = dataFolder.split(":");
            modId = split[1];
        }
        element.location = this.internalNamespace + ":" + element.location.split(":")[1];
        const nbtPath = isJar ?
            `${dataFolder}/${modId}/structures/${removeNamespace(element.location)}.nbt` :
            `${dataFolder}/structures/${removeNamespace(element.location)}.nbt`
        const nbt = new NbtStructure().fromTemplateNbt(nbtPath);
        const data = await readNbtFile(nbt.templatePath);
        if (data.parsed === null && data.type === null) {
            console.error(`Something went wrong. An NBT file would've been expected at ${nbt.templatePath}, but nothing has been found`)
            return;
        }
        nbt.data = data.parsed;
        nbt.type = data.type;
        const jigsaws = findJigsawBlocks(data.parsed);
        for (const jigsaw of jigsaws) {
            const jigsawPoolId = jigsaw.nbt.value.pool.value;
            jigsaw.nbt.value.pool.value = this.internalNamespace + ":" + this.internalName + '_' + jigsawPoolId.split(":")[1];
            if (structure.template_pools.some(p => p.internalName === this.internalName + '_' + removeNamespace(jigsawPoolId))) {
                continue;
            }
            if (!jigsawPoolId || jigsawPoolId.trim().length === 0) {
                debugger;
            }
            if (jigsawPoolId === "villager_normal") {
                debugger;
            }
            if (jigsawPoolId === "minecraft:empty" || jigsawPoolId === "minecraft:") {
                continue;
            }
            const jigsawPoolPath = isJar ?
                `${dataFolder}/${modId}/worldgen/template_pool/${removeNamespace(jigsawPoolId)}.json` :
                `${dataFolder}/worldgen/template_pool/${removeNamespace(jigsawPoolId)}.json`;
            if (jigsawPoolPath === "data/irons_spellbooks/worldgen/template_pool/.json") {
                debugger;
            }
            const jigsawPool = new TemplatePool().fromTemplate(await loadJsonFromPath(jigsawPoolPath));
            jigsawPool.withNamespace(this.internalNamespace).withName(this.internalName + '_' + removeNamespace(jigsawPoolId));
            structure.template_pools.push(jigsawPool);
            await this.traversePool(jigsawPool, structure, dataFolder);
        }
        this.nbts.push(nbt);
        nbt.withNamespace(this.internalNamespace).withName(this.internalName + '_' + removeNamespace(element.location));
        element.location = this.internalNamespace + ":" + this.internalName + '_' + element.location.split(":")[1];
        console.log(`Processed element: ${element.location}`);
    }

    afterBuild() {
        this.structures.forEach(structure => structure.afterBuild());
    }

    withNamespace(namespace: string): StructureDefinition {
        this.nbts?.forEach(nbt => nbt.withNamespace(namespace));
        return super.withNamespace(namespace);
    }

    withNbt(nbt: NbtStructure) {
        this.nbts.push(nbt);
        return this;
    }

    withStuctureSetJson(structureSet: StructureSet) {
        this.structureSet = structureSet;
        return this;
    }

    withStructureJson(structure: Structure) {
        this.structures.push(structure);
        return this;
    }

    withStructureJsons(structures: Structure[]) {
        this.structures = [...this.structures, ...structures];
        return
    }

    replaceBlock(command: ReplaceBlockCommand) {
        this.nbts.forEach(nbt => nbt.replaceBlock(command));
        return this;
    }

    replaceBlocks(commands: ReplaceBlockCommand[]) {
        commands.forEach(command => this.nbts.forEach(nbt => nbt.replaceBlock(command)));
        return this
    }

    replaceEntity(command: ReplaceEntityCommand) {
        this.nbts.forEach(nbt => nbt.replaceEntity(command));
        return this;
    }

    replaceEntities(commands: ReplaceEntityCommand[]) {
        commands.forEach(command => this.nbts.forEach(nbt => nbt.replaceEntity(command)));
        return this;
    }

    removeBiomes() {
        this.structures.forEach(structure => structure.removeBiomes());
        return this;
    }

    onBiomes(biomes: (string | Biome)[]) {
        this.structures.forEach(structure => structure.onBiomes(biomes));
        return this;
    }

    createBlockReplacementMap() {
        const palettes = this.nbts.map(nbt => nbt.exportPalette());
        const map = StructureDefinition.nbtCollectionToMap(palettes);
        const commands: ReplaceBlockCommand[] = [];
        for (const [oldBlock, newBlock] of map) {
            commands.push({oldBlock, newBlock});
        }
        return commands;
    }

    createEntityReplacementMap() {
        const entities = this.nbts.map(nbt => nbt.exportEntities());
        const map = StructureDefinition.nbtCollectionToMap(entities);
        const commands: ReplaceEntityCommand[] = [];
        for (const [oldEntity, newEntity] of map) {
            commands.push({oldEntity, newEntity});
        }
        return commands
    }

    private static nbtCollectionToMap(palettes: any[][]) {
        const paletteMap = new Map<string, string>();
        for (const palette of palettes) {
            for (const entry of palette) {
                paletteMap.set(entry, entry);
            }
        }
        return paletteMap;
    }

    async writeSelf() {
        await this.structureSet.writeSelf();
        this.structures.forEach(structure => structure.writeSelf());
        for (const nbt of this.nbts) {
            await nbt.writeSelf();
        }
    }
}

